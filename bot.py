import os
import asyncio
import logging
import tempfile
import yt_dlp
import re
import random
import time
import requests
from pyrogram import Client, filters
from pyrogram.errors import BadRequest, BadMsgNotification
from pyrogram.types import InputMediaPhoto, InputMediaVideo
import instaloader
import aiohttp
import shutil
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timedelta
import hashlib

API_ID = 26670278
API_HASH = "e3d77390fd9c22d98bb6bddca86fef1a"
BOT_TOKEN = "6788128988:AAEMmCSafiiEqtS5UWQQxfo--W0On7B6Q08"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ------------------------- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï -------------------------
user_processing = {}
processed_messages = set()

# ------------------------- –°–ò–°–¢–ï–ú–ê 48 IP-–ê–î–†–ï–°–û–í –ò –£–°–¢–†–û–ô–°–¢–í -------------------------
class IPGenerator:
    def __init__(self):
        self.base_ips = self.generate_base_ips()
        self.current_ips = self.base_ips.copy()
        self.rotation_time = 1800  # 30 –º–∏–Ω—É—Ç –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        self.last_rotation = datetime.now()
    
    def generate_base_ips(self):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º 48 –±–∞–∑–æ–≤—ã—Ö IP-–∞–¥—Ä–µ—Å–æ–≤ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –ø–æ–¥—Å–µ—Ç–µ–π"""
        base_ips = []
        
        # –†–∞–∑–Ω—ã–µ –ø–æ–¥—Å–µ—Ç–∏ –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
        subnets = [
            "104.28", "104.29", "108.177", "142.250", "172.217", 
            "173.194", "192.178", "203.208", "216.58", "216.239",
            "74.125", "64.233", "66.102", "66.249", "72.14", 
            "209.85", "207.126", "173.194", "216.58", "74.125"
        ]
        
        for i in range(48):
            subnet = random.choice(subnets)
            ip3 = random.randint(1, 254)
            ip4 = random.randint(1, 254)
            base_ips.append(f"{subnet}.{ip3}.{ip4}")
        
        logger.info(f"‚úÖ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ {len(base_ips)} –±–∞–∑–æ–≤—ã—Ö IP-–∞–¥—Ä–µ—Å–æ–≤")
        return base_ips
    
    def rotate_ips(self):
        """–†–æ—Ç–∞—Ü–∏—è IP-–∞–¥—Ä–µ—Å–æ–≤ –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç"""
        now = datetime.now()
        if (now - self.last_rotation).total_seconds() >= self.rotation_time:
            logger.info("üîÑ –†–æ—Ç–∞—Ü–∏—è IP-–∞–¥—Ä–µ—Å–æ–≤...")
            
            for i in range(len(self.current_ips)):
                # –ù–µ–º–Ω–æ–≥–æ –∏–∑–º–µ–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –æ–∫—Ç–µ—Ç –¥–ª—è "—Å–≤–µ–∂–µ—Å—Ç–∏"
                ip_parts = self.current_ips[i].split('.')
                ip_parts[3] = str((int(ip_parts[3]) + random.randint(1, 50)) % 255)
                self.current_ips[i] = '.'.join(ip_parts)
            
            self.last_rotation = now
            logger.info("‚úÖ IP-–∞–¥—Ä–µ—Å–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã")
    
    def get_ip_for_request(self, request_id):
        """–ü–æ–ª—É—á–∞–µ–º IP –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞"""
        self.rotate_ips()
        
        # –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤—ã–±–æ—Ä IP –Ω–∞ –æ—Å–Ω–æ–≤–µ ID –∑–∞–ø—Ä–æ—Å–∞
        ip_index = hash(request_id) % len(self.current_ips)
        selected_ip = self.current_ips[ip_index]
        
        return selected_ip

class MobileDeviceEmulator:
    def __init__(self):
        self.devices = self.generate_devices()
        self.ip_generator = IPGenerator()
    
    def generate_devices(self):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º 48 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤"""
        devices = []
        
        # –†–∞–∑–Ω—ã–µ –º–æ–¥–µ–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤
        phone_models = [
            # Samsung
            {"brand": "Samsung", "models": ["SM-G991B", "SM-G996B", "SM-G998B", "SM-A525F", "SM-A736B"]},
            # iPhone
            {"brand": "Apple", "models": ["iPhone14,1", "iPhone14,2", "iPhone14,3", "iPhone15,1", "iPhone15,2"]},
            # Xiaomi
            {"brand": "Xiaomi", "models": ["M2102J20SG", "M2012K11AG", "22021211RG", "2109119DG"]},
            # Google Pixel
            {"brand": "Google", "models": ["Pixel 6", "Pixel 6 Pro", "Pixel 7", "Pixel 7 Pro"]},
            # OnePlus
            {"brand": "OnePlus", "models": ["LE2113", "LE2123", "NE2213", "CPH2415"]},
        ]
        
        android_versions = [
            "10; Android 10", "11; Android 11", "12; Android 12", 
            "13; Android 13", "14; Android 14"
        ]
        
        for i in range(48):
            brand_data = random.choice(phone_models)
            model = random.choice(brand_data["models"])
            android = random.choice(android_versions)
            
            device = {
                'id': f"device_{i+1:02d}",
                'brand': brand_data["brand"],
                'model': model,
                'android_version': android,
                'user_agent': self.generate_user_agent(brand_data["brand"], model, android),
                'screen_resolution': self.generate_screen_resolution(brand_data["brand"]),
                'app_version': f"{random.randint(200, 280)}.0.0.{random.randint(10, 30)}.{random.randint(100, 200)}"
            }
            devices.append(device)
        
        logger.info(f"‚úÖ –°–æ–∑–¥–∞–Ω–æ {len(devices)} –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤")
        return devices
    
    def generate_user_agent(self, brand, model, android_version):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π User-Agent –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
        if brand == "Apple":
            return f"Mozilla/5.0 (iPhone; CPU iPhone OS {android_version.replace('; Android', '').replace(' ', '_')} like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1"
        else:
            return f"Mozilla/5.0 (Linux; Android {android_version}; {model}) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Mobile Safari/537.36"
    
    def generate_screen_resolution(self, brand):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –±—Ä–µ–Ω–¥–∞"""
        if brand == "Apple":
            return random.choice(["1170x2532", "1284x2778", "1179x2556"])
        else:
            return random.choice(["1080x2400", "1440x3200", "1080x2340", "1440x3040"])
    
    def get_device_for_request(self, request_id):
        """–ü–æ–ª—É—á–∞–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞"""
        device_index = hash(request_id) % len(self.devices)
        return self.devices[device_index]

# ------------------------- –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô SafeClient -------------------------
class SafeClient(Client):
    async def send(self, *args, **kwargs):
        for attempt in range(3):
            try:
                return await super().send(*args, **kwargs)
            except BadMsgNotification as e:
                if e.error_code == 16:
                    logger.warning(f"[WARN] BadMsgNotification [16], –∏—Å–ø—Ä–∞–≤–ª—è–µ–º msg_id, –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/3")
                    self.session.msg_id_offset = int(time.time() * 2**32)
                    await asyncio.sleep(1)
                else:
                    raise
        raise RuntimeError("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å msg_id —Å Telegram")

# ------------------------- –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –ö–õ–ò–ï–ù–¢ -------------------------
app = SafeClient(
    "video_bot_new_session_2024",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN,
    sleep_threshold=30,
    workers=100,
)

# ------------------------- –û–ë–ù–û–í–õ–ï–ù–ù–´–ô Instagram Downloader -------------------------
class InstagramDownloader:
    def __init__(self):
        self.device_emulator = MobileDeviceEmulator()
        self.thread_pool = ThreadPoolExecutor(max_workers=3)
        self.request_counter = 0

    def get_ydl_opts(self, request_id):
        """–ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ yt-dlp —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞"""
        device = self.device_emulator.get_device_for_request(request_id)
        ip_address = self.device_emulator.ip_generator.get_ip_for_request(request_id)
        
        # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
        headers = {
            'User-Agent': device['user_agent'],
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.9,en;q=0.8',
            'Accept-Encoding': 'gzip, deflate, br',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Cache-Control': 'max-age=0',
            # –≠–º—É–ª–∏—Ä—É–µ–º –º–æ–±–∏–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
            'Viewport-Width': device['screen_resolution'].split('x')[0],
            'Width': device['screen_resolution'].split('x')[0],
        }
        
        return {
            'outtmpl': 'downloads/%(id)s.%(ext)s',
            'format': 'best[height<=720]',
            'cookiefile': 'cookies.txt',
            'quiet': True,
            'no_warnings': True,
            'extract_flat': False,
            'noplaylist': True,
            
            # ‚ö° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò –°–ö–û–†–û–°–¢–ò
            'socket_timeout': 15,
            'extractretry': 1,
            'retries': 2,
            'fragment_retries': 2,
            'skip_unavailable_fragments': True,
            'keep_fragments': False,
            'concurrent_fragment_downloads': 6,
            
            # üÜï –£–ù–ò–ö–ê–õ–¨–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò –î–õ–Ø –ö–ê–ñ–î–û–ì–û –ó–ê–ü–†–û–°–ê
            'http_headers': headers,
            'user_agent': device['user_agent'],
            
            # –≠–º—É–ª—è—Ü–∏—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            'referer': 'https://www.instagram.com/',
            'origin': 'https://www.instagram.com',
        }

    async def download_instagram_content(self, url: str, out_path: str):
        """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"""
        try:
            self.request_counter += 1
            request_id = f"{int(time.time())}_{self.request_counter}"
            
            # –õ–æ–≥–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            device = self.device_emulator.get_device_for_request(request_id)
            ip_address = self.device_emulator.ip_generator.get_ip_for_request(request_id)
            logger.info(f"üì± –ó–∞–ø—Ä–æ—Å {request_id}: {device['brand']} {device['model']} | IP: {ip_address}")
            
            loop = asyncio.get_event_loop()
            content_type = self._determine_content_type(url)
            logger.info(f"üîç –û–ø—Ä–µ–¥–µ–ª–µ–Ω —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞: {content_type}")
            
            if '/stories/' in url:
                result = await loop.run_in_executor(
                    self.thread_pool, 
                    self._download_story_fast, 
                    url, out_path, content_type, request_id
                )
            else:
                result = await loop.run_in_executor(
                    self.thread_pool,
                    self._download_with_ytdlp_fast,
                    url, out_path, content_type, request_id
                )
            return result
        except Exception as e:
            logger.warning(f"–ë—ã—Å—Ç—Ä—ã–π –º–µ—Ç–æ–¥ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}, –ø—Ä–æ–±—É–µ–º instaloader")
            return await self._download_with_instaloader(url, out_path)

    def _determine_content_type(self, url: str) -> str:
        """–ë—ã—Å—Ç—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
        if '/reel/' in url or '/reels/' in url or '/tv/' in url:
            return 'video'
        elif '/p/' in url:
            return 'post'
        elif '/stories/' in url:
            return 'story'
        else:
            return 'auto'

    def _download_story_fast(self, url: str, out_path: str, content_type: str, request_id: str):
        """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–π —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"""
        try:
            ydl_opts = self.get_ydl_opts(request_id)
            ydl_opts['outtmpl'] = os.path.join(out_path, 'story_%(id)s.%(ext)s')
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                
                result = {
                    'type': 'story',
                    'files': [],
                    'title': f"instagram_story_{info.get('id', 'unknown')}",
                    'webpage_url': url,
                    'request_id': request_id
                }
                
                # –ë–´–°–¢–†–´–ô –ø–æ–∏—Å–∫ —Ñ–∞–π–ª–æ–≤
                if info.get('requested_downloads'):
                    for download in info['requested_downloads']:
                        file_path = download['filepath']
                        if os.path.exists(file_path) and self._is_media_file_fast(file_path):
                            result['files'].append(file_path)
                
                # –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
                if not result['files']:
                    for file in os.listdir(out_path):
                        file_path = os.path.join(out_path, file)
                        if self._is_media_file_fast(file_path):
                            result['files'].append(file_path)
                
                # –ë—ã—Å—Ç—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞
                if result['files']:
                    ext = result['files'][0].split('.')[-1].lower()
                    if ext in ['mp4', 'mov', 'avi']:
                        result['type'] = 'story_video'
                    else:
                        result['type'] = 'story_photo'
                
                return result
                
        except Exception as e:
            logger.warning(f"–ë—ã—Å—Ç—Ä—ã–π yt-dlp –¥–ª—è –∏—Å—Ç–æ—Ä–∏–π –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")
            raise

    def _download_with_ytdlp_fast(self, url: str, out_path: str, content_type: str, request_id: str):
        """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ yt-dlp —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"""
        ydl_opts = self.get_ydl_opts(request_id)
        ydl_opts['outtmpl'] = os.path.join(out_path, '%(id)s.%(ext)s')
        
        # –ë—ã—Å—Ç—Ä–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞
        if content_type == 'video':
            ydl_opts['format'] = 'best[ext=mp4]/best'
        elif content_type == 'photo':
            ydl_opts['format'] = 'best[ext=jpg]/best[ext=png]/best'
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            
            result = {
                'type': 'unknown',
                'files': [],
                'title': info.get('title', 'instagram_content'),
                'webpage_url': info.get('webpage_url', url),
                'request_id': request_id
            }
            
            # –ë–´–°–¢–†–´–ô —Å–±–æ—Ä —Ñ–∞–π–ª–æ–≤
            if info.get('requested_downloads'):
                for download in info['requested_downloads']:
                    file_path = download['filepath']
                    if os.path.exists(file_path) and self._is_media_file_fast(file_path):
                        result['files'].append(file_path)
            
            # –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            if not result['files']:
                for file in os.listdir(out_path):
                    file_path = os.path.join(out_path, file)
                    if self._is_media_file_fast(file_path):
                        result['files'].append(file_path)
            
            # –ë—ã—Å—Ç—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
            if info.get('_type') == 'playlist' or len(result['files']) > 1:
                result['type'] = 'carousel'
            else:
                if result['files']:
                    ext = result['files'][0].split('.')[-1].lower()
                    if ext in ['jpg', 'png', 'jpeg']:
                        result['type'] = 'photo'
                    elif ext in ['mp4', 'mov', 'avi']:
                        result['type'] = 'video'
            
            return result

    def _is_media_file_fast(self, file_path: str) -> bool:
        """–ë–´–°–¢–†–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞"""
        media_extensions = {'.jpg', '.jpeg', '.png', '.mp4', '.mov', '.avi', '.webm'}
        file_ext = os.path.splitext(file_path)[1].lower()
        return file_ext in media_extensions and os.path.isfile(file_path)

    # –û–°–¢–ê–í–õ–Ø–ï–ú –í–ê–®–ò –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø FALLBACK
    async def _download_story_with_instaloader(self, url: str, out_path: str, content_type: str):
        """–í–∞—à –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è fallback"""
        try:
            L = instaloader.Instaloader(
                dirname_pattern=out_path,
                filename_pattern='{profile}_{date_utc}',
                download_pictures=(content_type != 'video'),
                download_videos=(content_type != 'photo'),
                download_geotags=False,
                download_comments=False,
                save_metadata=False,
                compress_json=False
            )
            
            username = self._extract_story_username(url)
            if not username:
                raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å username –∏–∑ URL –∏—Å—Ç–æ—Ä–∏–∏")
            
            profile = instaloader.Profile.from_username(L.context, username)
            downloaded_files = []
            story_count = 0
            
            for story in L.get_stories([profile.userid]):
                for item in story.get_items():
                    if story_count >= 3:
                        break
                        
                    L.download_storyitem(item, target=os.path.join(out_path, f"story_{username}"))
                    
                    for file in os.listdir(out_path):
                        if file.startswith(f"story_{username}") and not file.endswith('.txt'):
                            full_path = os.path.join(out_path, file)
                            if self._is_media_file_fast(full_path):
                                downloaded_files.append(full_path)
                    
                    story_count += 1
            
            if not downloaded_files:
                raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∏—Å—Ç–æ—Ä–∏–∏")
            
            result = {
                'type': 'story',
                'files': downloaded_files,
                'title': f"instagram_story_{username}",
                'webpage_url': url,
                'count': len(downloaded_files)
            }
            
            if downloaded_files:
                ext = downloaded_files[0].split('.')[-1].lower()
                if ext in ['jpg', 'png', 'jpeg']:
                    result['type'] = 'story_photo'
                elif ext in ['mp4', 'mov', 'avi']:
                    result['type'] = 'story_video'
            
            return result
            
        except Exception as e:
            raise Exception(f"Instaloader –æ—à–∏–±–∫–∞ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–π: {str(e)}")

    async def _download_with_instaloader(self, url: str, out_path: str):
        """–í–∞—à –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è fallback"""
        try:
            L = instaloader.Instaloader(
                dirname_pattern=out_path,
                filename_pattern='{shortcode}',
                download_pictures=True,
                download_videos=True,
                download_geotags=False,
                download_comments=False,
                save_metadata=False,
                compress_json=False
            )
            
            shortcode = self._extract_shortcode(url)
            if not shortcode:
                raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å shortcode –∏–∑ URL")
            
            post = instaloader.Post.from_shortcode(L.context, shortcode)
            L.download_post(post, target=out_path)
            
            downloaded_files = []
            for file in os.listdir(out_path):
                file_path = os.path.join(out_path, file)
                if self._is_media_file_fast(file_path):
                    downloaded_files.append(file_path)
            
            result = {
                'type': 'carousel' if post.mediacount > 1 else 'photo',
                'files': downloaded_files,
                'title': f"instagram_{shortcode}",
                'webpage_url': url
            }
            
            if downloaded_files:
                ext = downloaded_files[0].split('.')[-1].lower()
                if ext in ['mp4', 'mov', 'avi']:
                    result['type'] = 'video'
                    
            return result
            
        except Exception as e:
            raise Exception(f"Instaloader –æ—à–∏–±–∫–∞: {str(e)}")

    def _extract_story_username(self, url: str):
        patterns = [
            r'instagram\.com/stories/([^/?]+)',
            r'instagram\.com/stories/([^/?]+)/(\d+)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        return None

    def _extract_shortcode(self, url: str):
        patterns = [
            r'instagram\.com/p/([^/?]+)',
            r'instagram\.com/reel/([^/?]+)',
            r'instagram\.com/stories/[^/]+/([^/?]+)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        return None

# ------------------------- –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê –î–õ–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ò -------------------------
@app.on_message(filters.command("devices"))
async def show_devices(client, message):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º"""
    try:
        downloader = InstagramDownloader()
        devices = downloader.device_emulator.devices
        
        response = "üì± **–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (48 —à—Ç—É–∫):**\n\n"
        
        for i, device in enumerate(devices[:10]):  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 10
            response += f"**{device['id']}:** {device['brand']} {device['model']}\n"
            response += f"User-Agent: {device['user_agent'][:50]}...\n\n"
        
        response += f"üîÑ IP-–∞–¥—Ä–µ—Å–∞ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç\n"
        response += f"üîß –ö–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"
        
        await message.reply_text(response)
        
    except Exception as e:
        await message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")

# ------------------------- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô) -------------------------
def extract_first_url(text: str) -> str:
    match = re.search(r"(https?://[^\s]+)", text)
    return match.group(1) if match else ""

def normalize_url(url: str) -> str:
    if "youtu.be/" in url:
        video_id = url.split("/")[-1].split("?")[0]
        return f"https://www.youtube.com/watch?v={video_id}"
    return url

def get_youtube_direct_url(url: str) -> str:
    ydl_opts = {
        "quiet": True, 
        "skip_download": True, 
        "format": "mp4[height<=720]/best[ext=mp4]/best",
        "socket_timeout": 10
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=False)
        return info.get("url")

def download_youtube_video(url: str, out_path: str) -> str:
    ydl_opts = {
        "outtmpl": os.path.join(out_path, "%(title).50s.%(ext)s"),
        "format": "best[height<=720][ext=mp4]/best[ext=mp4]",
        "noplaylist": True,
        "quiet": True,
        "retries": 1,
        "merge_output_format": "mp4",
        "concurrent_fragment_downloads": 4,
        "socket_timeout": 15,
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=True)
        return ydl.prepare_filename(info)

def check_cookies_file():
    if not os.path.exists("cookies.txt"):
        logger.error("‚ùå –§–∞–π–ª cookies.txt –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        return False
    logger.info("‚úÖ –§–∞–π–ª cookies.txt –Ω–∞–π–¥–µ–Ω")
    return True

async def cleanup_user_message(message, delay: int = 2):
    try:
        await asyncio.sleep(delay)
        await message.delete()
        logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {message.from_user.id}")
    except Exception as e:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

def cleanup_old_processed_messages():
    global processed_messages
    if len(processed_messages) > 1000:
        processed_messages = set(list(processed_messages)[-500:])
        logger.info("üßπ –û—á–∏—â–µ–Ω—ã —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –∏–∑ processed_messages")

def safe_remove_directory(dir_path: str):
    try:
        if os.path.exists(dir_path):
            shutil.rmtree(dir_path)
            logger.info(f"‚úÖ –£–¥–∞–ª–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {dir_path}")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é {dir_path}: {e}")

def validate_and_fix_extension(file_path: str) -> str:
    if not os.path.exists(file_path):
        return file_path
    
    try:
        import filetype
        kind = filetype.guess(file_path)
        
        if kind is None:
            return file_path
        
        current_ext = os.path.splitext(file_path)[1].lower()
        correct_ext = f".{kind.extension}"
        
        if current_ext != correct_ext:
            new_file_path = os.path.splitext(file_path)[0] + correct_ext
            try:
                os.rename(file_path, new_file_path)
                logger.info(f"‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ: {current_ext} -> {correct_ext}")
                return new_file_path
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ: {e}")
    except ImportError:
        logger.warning("‚ö†Ô∏è –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ filetype –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π")
    
    return file_path

# ------------------------- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–û–ë–©–ï–ù–ò–ô (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô) -------------------------
@app.on_message(filters.command("start"))
async def start(client, message):
    logger.info(f"üì© –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start –æ—Ç {message.from_user.id}")
    
    message_id = f"start_{message.id}_{message.from_user.id}"
    
    if message_id in processed_messages:
        logger.info("üîÑ –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏—Ä—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ /start")
        return
        
    processed_messages.add(message_id)
    
    try:
        welcome_msg = await message.reply_text(
            "‚ö° **–ë–´–°–¢–†–´–ô Instagram Downloader** ‚ö°\n\n"
            "üì• –û—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞ Instagram ‚Äî —è —Å–∫–∞—á–∞—é –ú–ì–ù–û–í–ï–ù–ù–û:\n"
            "‚Ä¢ üìπ –í–∏–¥–µ–æ –∏ —Ä–∏–ª—Å—ã\n" 
            "‚Ä¢ üì∏ –§–æ—Ç–æ\n"
            "‚Ä¢ üñºÔ∏è –ö–∞—Ä—É—Å–µ–ª–∏\n"
            "‚Ä¢ üì± –ò—Å—Ç–æ—Ä–∏–∏\n\n"
            "üöÄ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏!"
        )
        logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {message.from_user.id}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è: {e}")
    
    cleanup_old_processed_messages()

@app.on_message(filters.command(["help", "info"]))
async def help_command(client, message):
    logger.info(f"üì© –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ help –æ—Ç {message.from_user.id}")
    
    message_id = f"help_{message.id}_{message.from_user.id}"
    
    if message_id in processed_messages:
        return
        
    processed_messages.add(message_id)
    
    help_text = (
        "ü§ñ **–ü–æ–º–æ—â—å –ø–æ –±–æ—Ç—É**\n\n"
        "üì• –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞:\n"
        "‚Ä¢ Instagram —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ/—Ä–∏–ª—Å\n"
        "‚Ä¢ Instagram –∫–∞—Ä—É—Å–µ–ª—å\n" 
        "‚Ä¢ Instagram –∏—Å—Ç–æ—Ä–∏—é\n\n"
        "‚ö° **–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–û –î–õ–Ø –°–ö–û–†–û–°–¢–ò!**\n"
        "üìå –ë–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞"
    )
    
    try:
        await message.reply_text(help_text)
        logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–æ–º–æ—â—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {message.from_user.id}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–º–æ—â–∏: {e}")
    
    cleanup_old_processed_messages()

@app.on_message(filters.text & filters.private)
async def handle_text(client, message):
    logger.info(f"üì© –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {message.from_user.id}: {message.text[:50]}...")
    
    message_id = f"text_{message.id}_{message.from_user.id}"
    
    if message_id in processed_messages:
        logger.info("üîÑ –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏—Ä—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
        return
        
    if message.text and message.text.startswith('/'):
        logger.info("‚öôÔ∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—É")
        return
    
    user_id = message.from_user.id
    text = message.text.strip()
    
    url = extract_first_url(text)
    logger.info(f"üîç –ò–∑–≤–ª–µ—á–µ–Ω URL: {url}")
    
    if not url or not any(d in url for d in ["youtube.com", "youtu.be", "instagram.com"]):
        logger.info("‚ùå URL –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è")
        return

    processed_messages.add(message_id)
    
    if user_id in user_processing and user_processing[user_id].get('processing'):
        logger.info(f"‚è≥ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É–∂–µ –∏–º–µ–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã–π –∑–∞–ø—Ä–æ—Å")
        try:
            temp_msg = await message.reply_text("‚ö° –£–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å...")
            await asyncio.sleep(2)
            await temp_msg.delete()
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–Ω—è—Ç–æ—Å—Ç–∏: {e}")
        processed_messages.discard(message_id)
        return

    user_processing[user_id] = {'processing': True}
    
    status = None
    insta_downloader = InstagramDownloader()  # üÜï –¢–µ–ø–µ—Ä—å —Å —Å–∏—Å—Ç–µ–º–æ–π 48 —É—Å—Ç—Ä–æ–π—Å—Ç–≤
    tmp_dir = None
    
    try:
        url = normalize_url(url)
        logger.info(f"üîÑ –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π URL: {url}")
        
        status = await message.reply_text("‚ö° –û–ø—Ä–µ–¥–µ–ª—è—é —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞...")
        
        if "youtube" in url or "youtu.be" in url:
            await _handle_youtube_fast(client, message, url, status)
            
        elif "instagram.com" in url:
            tmp_dir = tempfile.mkdtemp()
            await _handle_instagram_fast(client, message, url, status, insta_downloader, tmp_dir)

        await message.delete()
        logger.info(f"‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
        
        if status:
            try:
                error_msg = await message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")
                await asyncio.sleep(4)
                await error_msg.delete()
            except:
                pass
                
    finally:
        if status:
            try:
                await status.delete()
            except:
                pass
                
        if tmp_dir and os.path.exists(tmp_dir):
            safe_remove_directory(tmp_dir)
                
        if user_id in user_processing:
            user_processing[user_id]['processing'] = False
            
        cleanup_old_processed_messages()

async def _handle_youtube_fast(client, message, url, status):
    """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –æ–±—Ä–∞–±–æ—Ç–∫–∞ YouTube"""
    try:
        await status.edit_text("üîó –ü–æ–ª—É—á–∞—é –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É YouTube...")
        direct_url = await asyncio.to_thread(get_youtube_direct_url, url)
        
        await status.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∏–¥–µ–æ...")
        await message.reply_video(
            direct_url, 
            caption="üì• YouTube –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ @azams_bot"
        )
        logger.info("‚úÖ YouTube –≤–∏–¥–µ–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É")
        
    except Exception as e:
        logger.warning(f"‚ùå –ü—Ä—è–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞: {e}, —Å–∫–∞—á–∏–≤–∞—é —Ñ–∞–π–ª...")
        await status.edit_text("üì• –°–∫–∞—á–∏–≤–∞—é –≤–∏–¥–µ–æ...")
        tmp_dir = tempfile.mkdtemp()
        
        try:
            file_path = await asyncio.to_thread(download_youtube_video, url, tmp_dir)
            await status.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∏–¥–µ–æ...")
            await message.reply_video(
                file_path, 
                caption="üì• YouTube –≤–∏–¥–µ–æ —á–µ—Ä–µ–∑ @azams_bot"
            )
            logger.info("‚úÖ YouTube –≤–∏–¥–µ–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–∞–∫ —Ñ–∞–π–ª")
            
        except Exception as download_error:
            raise download_error
        finally:
            if os.path.exists(tmp_dir):
                safe_remove_directory(tmp_dir)

async def _handle_instagram_fast(client, message, url, status, downloader, tmp_dir):
    """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –æ–±—Ä–∞–±–æ—Ç–∫–∞ Instagram"""
    if not check_cookies_file():
        await status.edit_text("‚ùå –§–∞–π–ª cookies.txt –Ω–µ –Ω–∞–π–¥–µ–Ω. Instagram –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
        await asyncio.sleep(3)
        return
        
    try:
        await status.edit_text("‚ö° –°–∫–∞—á–∏–≤–∞—é –∫–æ–Ω—Ç–µ–Ω—Ç...")
        
        content_info = await downloader.download_instagram_content(url, tmp_dir)
        
        if not content_info.get('files'):
            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª—ã")
        
        # –ë–´–°–¢–†–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π
        validated_files = []
        for file_path in content_info['files']:
            if os.path.exists(file_path):
                fixed_path = validate_and_fix_extension(file_path)
                validated_files.append(fixed_path)
        
        if not validated_files:
            raise Exception("–ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏")
        
        content_info['files'] = validated_files
        
        await status.edit_text(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é {content_info['type']}...")
        
        # –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –æ—Ç–ø—Ä–∞–≤–∫–∞
        await send_content_fast(client, message, content_info)
        
        logger.info(f"‚úÖ Instagram {content_info['type']} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω ({len(validated_files)} —Ñ–∞–π–ª–æ–≤)")
        
    except Exception as e:
        raise e

async def send_content_fast(client, message, content_info):
    """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
    files = content_info['files']
    content_type = content_info['type']
    
    if content_type in ['photo', 'story_photo']:
        tasks = []
        for file_path in files[:10]:
            if os.path.exists(file_path):
                task = message.reply_photo(
                    file_path,
                    caption=f"üì∏ Instagram {'–∏—Å—Ç–æ—Ä–∏—è' if 'story' in content_type else '—Ñ–æ—Ç–æ'} —á–µ—Ä–µ–∑ @azams_bot"
                )
                tasks.append(task)
        
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
            
    elif content_type in ['video', 'story_video']:
        tasks = []
        for file_path in files[:10]:
            if os.path.exists(file_path):
                task = message.reply_video(
                    file_path,
                    caption=f"üìπ Instagram {'–∏—Å—Ç–æ—Ä–∏—è' if 'story' in content_type else '–≤–∏–¥–µ–æ'} —á–µ—Ä–µ–∑ @azams_bot"
                )
                tasks.append(task)
        
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
            
    elif content_type == 'carousel':
        await _send_carousel_fast(client, message, files)

async def _send_carousel_fast(client, message, files):
    """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–∞—Ä—É—Å–µ–ª–∏"""
    media_group = []
    
    for i, file_path in enumerate(files[:10]):
        if not os.path.exists(file_path):
            continue
            
        try:
            if file_path.lower().endswith(('.jpg', '.jpeg', '.png')):
                media_item = InputMediaPhoto(file_path)
                if i == 0:
                    media_item.caption = "üñºÔ∏è Instagram –∫–∞—Ä—É—Å–µ–ª—å —á–µ—Ä–µ–∑ @azams_bot"
                media_group.append(media_item)
                
            elif file_path.lower().endswith(('.mp4', '.mov', '.avi')):
                media_item = InputMediaVideo(file_path)
                if i == 0:
                    media_item.caption = "üé¨ Instagram –∫–∞—Ä—É—Å–µ–ª—å —á–µ—Ä–µ–∑ @azams_bot"
                media_group.append(media_item)
                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª: {file_path}, –æ—à–∏–±–∫–∞: {e}")
    
    if media_group:
        try:
            await message.reply_media_group(media_group)
            logger.info(f"‚úÖ –ú–µ–¥–∏–∞–≥—Ä—É–ø–ø–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ ({len(media_group)} —Ñ–∞–π–ª–æ–≤)")
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–µ–¥–∏–∞–≥—Ä—É–ø–ø—ã: {e}")
            tasks = []
            for file_path in files[:5]:
                if os.path.exists(file_path):
                    if file_path.lower().endswith(('.jpg', '.jpeg', '.png')):
                        tasks.append(message.reply_photo(file_path))
                    elif file_path.lower().endswith(('.mp4', '.mov', '.avi')):
                        tasks.append(message.reply_video(file_path))
            
            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)

# ------------------------- –ó–ê–ü–£–°–ö -------------------------
if __name__ == "__main__":
    old_sessions = ["video_bot_new_session_2024.session", "video_bot_new_session_2024.session-journal"]
    for session_file in old_sessions:
        if os.path.exists(session_file):
            try:
                os.remove(session_file)
                logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª —Å–µ—Å—Å–∏–∏: {session_file}")
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å {session_file}: {e}")
    
    if os.path.exists("cookies.txt"):
        logger.info("‚úÖ –§–∞–π–ª cookies.txt –Ω–∞–π–¥–µ–Ω - Instagram –¥–æ—Å—Ç—É–ø–µ–Ω")
    else:
        logger.warning("‚ö†Ô∏è –§–∞–π–ª cookies.txt –Ω–µ –Ω–∞–π–¥–µ–Ω - Instagram –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
    
    if not os.path.exists("downloads"):
        os.makedirs("downloads")
    
    logger.info("üöÄ –ó–ê–ü–£–°–ö –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ì–û –ë–û–¢–ê –° 48 –£–°–¢–†–û–ô–°–¢–í–ê–ú–ò...")
    logger.info("üì± 48 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö IP-–∞–¥—Ä–µ—Å–æ–≤ –∏ User-Agent")
    logger.info("üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç")
    
    try:
        app.run()
        logger.info("‚úÖ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞: {e}")
