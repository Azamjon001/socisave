import os
import asyncio
import logging
import tempfile
import yt_dlp
import re
import random
import time
import requests
from pyrogram import Client, filters
from pyrogram.errors import BadRequest, BadMsgNotification
from pyrogram.types import InputMediaPhoto, InputMediaVideo
import instaloader
import aiohttp
import shutil
from concurrent.futures import ThreadPoolExecutor

API_ID = 26670278
API_HASH = "e3d77390fd9c22d98bb6bddca86fef1a"
BOT_TOKEN = "6788128988:AAEMmCSafiiEqtS5UWQQxfo--W0On7B6Q08"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ------------------------- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï -------------------------
user_processing = {}
processed_messages = set()

# ------------------------- –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô SafeClient -------------------------
class SafeClient(Client):
    async def send(self, *args, **kwargs):
        for attempt in range(3):
            try:
                return await super().send(*args, **kwargs)
            except BadMsgNotification as e:
                if e.error_code == 16:
                    logger.warning(f"[WARN] BadMsgNotification [16], –∏—Å–ø—Ä–∞–≤–ª—è–µ–º msg_id, –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/3")
                    self.session.msg_id_offset = int(time.time() * 2**32)
                    await asyncio.sleep(1)
                else:
                    raise
        raise RuntimeError("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å msg_id —Å Telegram")

# ------------------------- –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –ö–õ–ò–ï–ù–¢ -------------------------
app = SafeClient(
    "video_bot_new_session_2024",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN,
    sleep_threshold=30,
    workers=100,
)

# ------------------------- –£–õ–£–ß–®–ï–ù–ù–´–ô Instagram Downloader -------------------------
class InstagramDownloader:
    def __init__(self):
        # –ü–†–û–í–ï–†–Ø–ï–ú –ò –§–ò–ö–°–ò–ú COOKIES –ü–†–ò –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–ò
        self._setup_cookies()
        
        # –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò yt-dlp
        self.fast_ydl_opts = {
            'outtmpl': 'downloads/%(id)s.%(ext)s',
            'format': 'best[height<=720]',
            'cookiefile': 'cookies.txt',
            'quiet': True,
            'no_warnings': True,
            'extract_flat': False,
            'noplaylist': True,
            
            # ‚ö° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò –°–ö–û–†–û–°–¢–ò –ò –°–¢–ê–ë–ò–õ–¨–ù–û–°–¢–ò
            'socket_timeout': 20,
            'extractretry': 2,
            'retries': 3,
            'fragment_retries': 3,
            'skip_unavailable_fragments': True,
            'keep_fragments': False,
            'concurrent_fragment_downloads': 4,
            
            # –£–õ–£–ß–®–ï–ù–ù–´–ï –ó–ê–ì–û–õ–û–í–ö–ò
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': '*/*',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Referer': 'https://www.instagram.com/',
                'Origin': 'https://www.instagram.com',
            }
        }
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è instaloader
        self.instaloader_session = "instagram_session"
        self.thread_pool = ThreadPoolExecutor(max_workers=3)

    def _setup_cookies(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ —Ñ–∏–∫—Å–∏–º cookies —Ñ–∞–π–ª"""
        if not os.path.exists("cookies.txt"):
            logger.error("‚ùå –§–∞–π–ª cookies.txt –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            # –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π —Ñ–∞–π–ª cookies
            self._create_default_cookies()
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç cookies
        with open("cookies.txt", "r", encoding="utf-8") as f:
            content = f.read()
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º Netscape —Ñ–æ—Ä–º–∞—Ç
        if not content.startswith("# Netscape HTTP Cookie File"):
            logger.warning("‚ö†Ô∏è –§–∞–π–ª cookies –Ω–µ –≤ Netscape —Ñ–æ—Ä–º–∞—Ç–µ, –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å...")
            self._fix_cookies_format(content)
        
        logger.info("‚úÖ –§–∞–π–ª cookies.txt –ø—Ä–æ–≤–µ—Ä–µ–Ω")
        return True

    def _create_default_cookies(self):
        """–°–æ–∑–¥–∞–µ—Ç –±–∞–∑–æ–≤—ã–π —Ñ–∞–π–ª cookies"""
        default_cookies = """# Netscape HTTP Cookie File
# This file is generated by Instagram Downloader
# To update cookies, export from your browser while logged into Instagram

.instagram.com	TRUE	/	TRUE	0	sessionid	YOUR_SESSION_ID_HERE
.instagram.com	TRUE	/	TRUE	0	csrftoken	YOUR_CSRF_TOKEN_HERE
.instagram.com	TRUE	/	TRUE	0	ds_user_id	YOUR_USER_ID_HERE
"""
        with open("cookies.txt", "w", encoding="utf-8") as f:
            f.write(default_cookies)
        logger.warning("üìù –°–æ–∑–¥–∞–Ω —à–∞–±–ª–æ–Ω cookies.txt - –∑–∞–ø–æ–ª–Ω–∏—Ç–µ —Å–≤–æ–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏!")

    def _fix_cookies_format(self, content):
        """–ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç —Ñ–æ—Ä–º–∞—Ç cookies —Ñ–∞–π–ª–∞"""
        try:
            lines = content.strip().split('\n')
            fixed_lines = ["# Netscape HTTP Cookie File", "# Fixed by Instagram Downloader"]
            
            for line in lines:
                if line.strip() and not line.startswith('#'):
                    parts = line.split('\t')
                    if len(parts) >= 7:
                        fixed_lines.append(line)
                    else:
                        # –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
                        if '=' in line:
                            name_value = line.split('=', 1)
                            if len(name_value) == 2:
                                fixed_lines.append(f".instagram.com\tTRUE\t/\tTRUE\t0\t{name_value[0]}\t{name_value[1]}")
            
            with open("cookies.txt", "w", encoding="utf-8") as f:
                f.write('\n'.join(fixed_lines))
            logger.info("‚úÖ –§–æ—Ä–º–∞—Ç cookies –∏—Å–ø—Ä–∞–≤–ª–µ–Ω")
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è cookies: {e}")

    async def download_instagram_content(self, url: str, out_path: str):
        """–£–õ–£–ß–®–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Å –ª—É—á—à–µ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
        try:
            loop = asyncio.get_event_loop()
            content_type = self._determine_content_type(url)
            logger.info(f"üîç –û–ø—Ä–µ–¥–µ–ª–µ–Ω —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞: {content_type}")
            
            # –ü–ï–†–í–´–ô –°–ü–û–°–û–ë: yt-dlp —Å cookies
            try:
                result = await loop.run_in_executor(
                    self.thread_pool,
                    self._download_with_ytdlp_enhanced,
                    url, out_path, content_type
                )
                if result and result.get('files'):
                    logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω–æ —á–µ—Ä–µ–∑ yt-dlp —Å cookies")
                    return result
            except Exception as e:
                logger.warning(f"üìå yt-dlp —Å cookies –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")

            # –í–¢–û–†–û–ô –°–ü–û–°–û–ë: instaloader —Å —Å–µ—Å—Å–∏–µ–π
            try:
                result = await self._download_with_instaloader_enhanced(url, out_path)
                if result and result.get('files'):
                    logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω–æ —á–µ—Ä–µ–∑ instaloader")
                    return result
            except Exception as e:
                logger.warning(f"üìå Instaloader –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")

            # –¢–†–ï–¢–ò–ô –°–ü–û–°–û–ë: yt-dlp –±–µ–∑ cookies (fallback)
            try:
                result = await loop.run_in_executor(
                    self.thread_pool,
                    self._download_with_ytdlp_fallback,
                    url, out_path, content_type
                )
                if result and result.get('files'):
                    logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω–æ —á–µ—Ä–µ–∑ yt-dlp fallback")
                    return result
            except Exception as e:
                logger.warning(f"üìå yt-dlp fallback –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")

            raise Exception("–í—Å–µ –º–µ—Ç–æ–¥—ã —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏")

        except Exception as e:
            logger.error(f"‚ùå –í—Å–µ –º–µ—Ç–æ–¥—ã —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –ø—Ä–æ–≤–∞–ª–∏–ª–∏—Å—å: {e}")
            raise

    def _download_with_ytdlp_enhanced(self, url: str, out_path: str, content_type: str):
        """–£–õ–£–ß–®–ï–ù–ù–´–ô –º–µ—Ç–æ–¥ yt-dlp —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π cookies"""
        ydl_opts = self.fast_ydl_opts.copy()
        ydl_opts['outtmpl'] = os.path.join(out_path, '%(id)s.%(ext)s')
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É cookies
        if os.path.exists("cookies.txt"):
            ydl_opts['cookiefile'] = "cookies.txt"
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
        if content_type == 'video':
            ydl_opts['format'] = 'best[ext=mp4]/best'
        elif content_type == 'photo':
            ydl_opts['format'] = 'best[ext=jpg]/best[ext=png]/best'
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ö–æ–¥–Ω—ã–µ –ø—É—Ç–∏
        ydl_opts['extractor_args'] = {
            'instagram': {
                'skip_auth': True,
                'extract_comments': False,
                'post_filter': 'none'
            }
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            
            result = {
                'type': 'unknown',
                'files': [],
                'title': info.get('title', 'instagram_content'),
                'webpage_url': info.get('webpage_url', url)
            }
            
            # –°–±–æ—Ä —Ñ–∞–π–ª–æ–≤
            if info.get('requested_downloads'):
                for download in info['requested_downloads']:
                    file_path = download['filepath']
                    if os.path.exists(file_path) and self._is_media_file_fast(file_path):
                        result['files'].append(file_path)
            
            # –ü–æ–∏—Å–∫ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            if not result['files']:
                for file in os.listdir(out_path):
                    file_path = os.path.join(out_path, file)
                    if self._is_media_file_fast(file_path):
                        result['files'].append(file_path)
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞
            if info.get('_type') == 'playlist' or len(result['files']) > 1:
                result['type'] = 'carousel'
            else:
                if result['files']:
                    ext = result['files'][0].split('.')[-1].lower()
                    if ext in ['jpg', 'png', 'jpeg']:
                        result['type'] = 'photo'
                    elif ext in ['mp4', 'mov', 'avi']:
                        result['type'] = 'video'
            
            return result

    def _download_with_ytdlp_fallback(self, url: str, out_path: str, content_type: str):
        """Fallback –º–µ—Ç–æ–¥ –±–µ–∑ cookies –¥–ª—è –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
        ydl_opts = {
            'outtmpl': os.path.join(out_path, '%(id)s.%(ext)s'),
            'format': 'best[height<=480]',  # –ë–æ–ª–µ–µ –Ω–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
            'quiet': True,
            'no_warnings': False,
            'socket_timeout': 30,
            'extractretry': 1,
            'retries': 1,
            'fragment_retries': 1,
            'skip_unavailable_fragments': True,
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': '*/*',
            }
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            
            result = {
                'type': 'unknown',
                'files': [],
                'title': info.get('title', 'instagram_content'),
                'webpage_url': info.get('webpage_url', url)
            }
            
            for file in os.listdir(out_path):
                file_path = os.path.join(out_path, file)
                if self._is_media_file_fast(file_path):
                    result['files'].append(file_path)
            
            return result

    async def _download_with_instaloader_enhanced(self, url: str, out_path: str):
        """–£–õ–£–ß–®–ï–ù–ù–´–ô –º–µ—Ç–æ–¥ instaloader —Å —Å–µ—Å—Å–∏–µ–π"""
        try:
            L = instaloader.Instaloader(
                dirname_pattern=out_path,
                filename_pattern='{shortcode}',
                download_pictures=True,
                download_videos=True,
                download_geotags=False,
                download_comments=False,
                save_metadata=False,
                compress_json=False,
                request_timeout=30
            )
            
            # –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–µ—Å—Å–∏—é
            try:
                if os.path.exists(f"{self.instaloader_session}.session"):
                    L.load_session_from_file(username=None, filename=self.instaloader_session)
                    logger.info("‚úÖ –°–µ—Å—Å–∏—è instaloader –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–µ—Å—Å–∏—é instaloader: {e}")

            shortcode = self._extract_shortcode(url)
            if not shortcode:
                raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å shortcode –∏–∑ URL")
            
            post = instaloader.Post.from_shortcode(L.context, shortcode)
            L.download_post(post, target=out_path)
            
            downloaded_files = []
            for file in os.listdir(out_path):
                file_path = os.path.join(out_path, file)
                if self._is_media_file_fast(file_path):
                    downloaded_files.append(file_path)
            
            result = {
                'type': 'carousel' if post.mediacount > 1 else 'photo',
                'files': downloaded_files,
                'title': f"instagram_{shortcode}",
                'webpage_url': url
            }
            
            if downloaded_files:
                ext = downloaded_files[0].split('.')[-1].lower()
                if ext in ['mp4', 'mov', 'avi']:
                    result['type'] = 'video'
                    
            return result
            
        except Exception as e:
            raise Exception(f"Instaloader –æ—à–∏–±–∫–∞: {str(e)}")

    def _determine_content_type(self, url: str) -> str:
        """–ë—ã—Å—Ç—Ä–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
        if '/reel/' in url or '/reels/' in url or '/tv/' in url:
            return 'video'
        elif '/p/' in url:
            return 'post'
        elif '/stories/' in url:
            return 'story'
        else:
            return 'auto'

    def _is_media_file_fast(self, file_path: str) -> bool:
        """–ë–´–°–¢–†–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞"""
        media_extensions = {'.jpg', '.jpeg', '.png', '.mp4', '.mov', '.avi', '.webm'}
        file_ext = os.path.splitext(file_path)[1].lower()
        return file_ext in media_extensions and os.path.isfile(file_path)

    def _extract_shortcode(self, url: str):
        patterns = [
            r'instagram\.com/p/([^/?]+)',
            r'instagram\.com/reel/([^/?]+)',
            r'instagram\.com/stories/[^/]+/([^/?]+)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        return None

# ------------------------- –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò -------------------------
def extract_first_url(text: str) -> str:
    match = re.search(r"(https?://[^\s]+)", text)
    return match.group(1) if match else ""

def normalize_url(url: str) -> str:
    if "youtu.be/" in url:
        video_id = url.split("/")[-1].split("?")[0]
        return f"https://www.youtube.com/watch?v={video_id}"
    return url

def get_youtube_direct_url(url: str) -> str:
    ydl_opts = {
        "quiet": True, 
        "skip_download": True, 
        "format": "mp4[height<=720]/best[ext=mp4]/best",
        "socket_timeout": 10
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=False)
        return info.get("url")

def download_youtube_video(url: str, out_path: str) -> str:
    ydl_opts = {
        "outtmpl": os.path.join(out_path, "%(title).50s.%(ext)s"),
        "format": "best[height<=720][ext=mp4]/best[ext=mp4]",
        "noplaylist": True,
        "quiet": True,
        "retries": 1,
        "merge_output_format": "mp4",
        "concurrent_fragment_downloads": 4,
        "socket_timeout": 15,
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(url, download=True)
        return ydl.prepare_filename(info)

def check_cookies_file():
    if not os.path.exists("cookies.txt"):
        logger.error("‚ùå –§–∞–π–ª cookies.txt –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        return False
    logger.info("‚úÖ –§–∞–π–ª cookies.txt –Ω–∞–π–¥–µ–Ω")
    return True

async def cleanup_user_message(message, delay: int = 2):
    try:
        await asyncio.sleep(delay)
        await message.delete()
        logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {message.from_user.id}")
    except Exception as e:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

def cleanup_old_processed_messages():
    global processed_messages
    if len(processed_messages) > 1000:
        processed_messages = set(list(processed_messages)[-500:])
        logger.info("üßπ –û—á–∏—â–µ–Ω—ã —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –∏–∑ processed_messages")

def safe_remove_directory(dir_path: str):
    try:
        if os.path.exists(dir_path):
            shutil.rmtree(dir_path)
            logger.info(f"‚úÖ –£–¥–∞–ª–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {dir_path}")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é {dir_path}: {e}")

def validate_and_fix_extension(file_path: str) -> str:
    if not os.path.exists(file_path):
        return file_path
    
    try:
        import filetype
        kind = filetype.guess(file_path)
        
        if kind is None:
            return file_path
        
        current_ext = os.path.splitext(file_path)[1].lower()
        correct_ext = f".{kind.extension}"
        
        if current_ext != correct_ext:
            new_file_path = os.path.splitext(file_path)[0] + correct_ext
            try:
                os.rename(file_path, new_file_path)
                logger.info(f"‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ: {current_ext} -> {correct_ext}")
                return new_file_path
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ: {e}")
    except ImportError:
        logger.warning("‚ö†Ô∏è –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ filetype –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π")
    
    return file_path

# ------------------------- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ó–ê–ì–†–£–ó–ß–ò–ö–ê -------------------------
instagram_downloader = InstagramDownloader()

# ------------------------- –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–û–ë–©–ï–ù–ò–ô -------------------------

@app.on_message(filters.command("start"))
async def start(client, message):
    logger.info(f"üì© –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /start –æ—Ç {message.from_user.id}")
    
    message_id = f"start_{message.id}_{message.from_user.id}"
    
    if message_id in processed_messages:
        logger.info("üîÑ –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏—Ä—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ /start")
        return
        
    processed_messages.add(message_id)
    
    try:
        welcome_msg = await message.reply_text(
            "‚ö° **–ë–´–°–¢–†–´–ô Instagram Downloader** ‚ö°\n\n"
            "üì• –û—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞ Instagram ‚Äî —è —Å–∫–∞—á–∞—é –ú–ì–ù–û–í–ï–ù–ù–û:\n"
            "‚Ä¢ üìπ –í–∏–¥–µ–æ –∏ —Ä–∏–ª—Å—ã\n"
            "‚Ä¢ üì∏ –§–æ—Ç–æ\n"
            "‚Ä¢ üñºÔ∏è –ö–∞—Ä—É—Å–µ–ª–∏\n"
            "‚Ä¢ üì± –ò—Å—Ç–æ—Ä–∏–∏\n\n"
            "üöÄ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏!"
        )
        logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {message.from_user.id}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è: {e}")
    
    cleanup_old_processed_messages()

@app.on_message(filters.command(["help", "info"]))
async def help_command(client, message):
    logger.info(f"üì© –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ help –æ—Ç {message.from_user.id}")
    
    message_id = f"help_{message.id}_{message.from_user.id}"
    
    if message_id in processed_messages:
        return
        
    processed_messages.add(message_id)
    
    help_text = (
        "ü§ñ **–ü–æ–º–æ—â—å –ø–æ –±–æ—Ç—É**\n\n"
        "üì• –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞:\n"
        "‚Ä¢ Instagram —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ/—Ä–∏–ª—Å\n"
        "‚Ä¢ Instagram –∫–∞—Ä—É—Å–µ–ª—å\n" 
        "‚Ä¢ Instagram –∏—Å—Ç–æ—Ä–∏—é\n\n"
        "‚ö° **–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–û –î–õ–Ø –°–ö–û–†–û–°–¢–ò!**\n"
        "üìå –ë–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞"
    )
    
    try:
        await message.reply_text(help_text)
        logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–æ–º–æ—â—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {message.from_user.id}")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–º–æ—â–∏: {e}")
    
    cleanup_old_processed_messages()

@app.on_message(filters.text & filters.private)
async def handle_text(client, message):
    logger.info(f"üì© –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {message.from_user.id}: {message.text[:50]}...")
    
    message_id = f"text_{message.id}_{message.from_user.id}"
    
    if message_id in processed_messages:
        logger.info("üîÑ –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏—Ä—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
        return
        
    if message.text and message.text.startswith('/'):
        logger.info("‚öôÔ∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–∞–Ω–¥—É")
        return
    
    user_id = message.from_user.id
    text = message.text.strip()
    
    url = extract_first_url(text)
    logger.info(f"üîç –ò–∑–≤–ª–µ—á–µ–Ω URL: {url}")
    
    if not url or not any(d in url for d in ["youtube.com", "youtu.be", "instagram.com"]):
        logger.info("‚ùå URL –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è")
        return

    processed_messages.add(message_id)
    
    if user_id in user_processing and user_processing[user_id]:
        logger.info(f"‚è≥ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è")
        try:
            await message.reply_text("‚è≥ –í–∞—à –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å –µ—â–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è...")
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–Ω—è—Ç–æ—Å—Ç–∏: {e}")
        return

    user_processing[user_id] = True
    processing_msg = None

    try:
        # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
        with tempfile.TemporaryDirectory() as temp_dir:
            logger.info(f"üìÅ –°–æ–∑–¥–∞–Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {temp_dir}")
            
            processing_msg = await message.reply_text("‚ö° –°–∫–∞—á–∏–≤–∞—é –∫–æ–Ω—Ç–µ–Ω—Ç...")
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏ —Å–∫–∞—á–∏–≤–∞–µ–º
            if "instagram.com" in url:
                logger.info("üì∏ –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ Instagram —Å—Å—ã–ª–∫–∞")
                
                if not check_cookies_file():
                    await processing_msg.edit_text("‚ö†Ô∏è –§–∞–π–ª cookies.txt –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç –Ω–µ —Ä–∞–±–æ—Ç–∞—Ç—å –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞.")
                    await asyncio.sleep(2)
                
                result = await instagram_downloader.download_instagram_content(url, temp_dir)
                
            elif "youtube.com" in url or "youtu.be" in url:
                logger.info("üé• –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ YouTube —Å—Å—ã–ª–∫–∞")
                normalized_url = normalize_url(url)
                file_path = download_youtube_video(normalized_url, temp_dir)
                result = {
                    'type': 'video',
                    'files': [file_path],
                    'title': os.path.basename(file_path),
                    'webpage_url': normalized_url
                }
            else:
                await processing_msg.edit_text("‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Å—Å—ã–ª–∫–∏")
                return

            if not result or not result.get('files'):
                await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç")
                return

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            files = result['files']
            content_type = result.get('type', 'unknown')
            
            await processing_msg.edit_text(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é {len(files)} —Ñ–∞–π–ª(–æ–≤)...")
            
            if content_type in ['photo', 'story_photo'] and len(files) == 1:
                # –û–¥–Ω–æ —Ñ–æ—Ç–æ
                file_path = validate_and_fix_extension(files[0])
                await message.reply_photo(
                    photo=file_path,
                    caption=f"üì∏ Instagram Photo\nüîó {url}"
                )
                
            elif content_type in ['video', 'story_video'] and len(files) == 1:
                # –û–¥–Ω–æ –≤–∏–¥–µ–æ
                file_path = validate_and_fix_extension(files[0])
                await message.reply_video(
                    video=file_path,
                    caption=f"üé• Instagram Video\nüîó {url}",
                    supports_streaming=True
                )
                
            elif content_type == 'carousel' or len(files) > 1:
                # –ö–∞—Ä—É—Å–µ–ª—å –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤
                media_group = []
                for i, file_path in enumerate(files):
                    file_path = validate_and_fix_extension(file_path)
                    if file_path.lower().endswith(('.jpg', '.jpeg', '.png')):
                        if i == 0:
                            media_group.append(InputMediaPhoto(file_path, caption=f"üñºÔ∏è Instagram Post\nüîó {url}"))
                        else:
                            media_group.append(InputMediaPhoto(file_path))
                    elif file_path.lower().endswith(('.mp4', '.mov', '.avi')):
                        if i == 0:
                            media_group.append(InputMediaVideo(file_path, caption=f"üé• Instagram Video\nüîó {url}"))
                        else:
                            media_group.append(InputMediaVideo(file_path))
                
                if media_group:
                    await message.reply_media_group(media_group)
                    
            else:
                # Fallback - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –ø–æ –æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏
                for file_path in files:
                    file_path = validate_and_fix_extension(file_path)
                    if file_path.lower().endswith(('.jpg', '.jpeg', '.png')):
                        await message.reply_photo(file_path)
                    elif file_path.lower().endswith(('.mp4', '.mov', '.avi')):
                        await message.reply_video(file_path, supports_streaming=True)
                    else:
                        await message.reply_document(file_path)
            
            await processing_msg.edit_text("‚úÖ –ö–æ–Ω—Ç–µ–Ω—Ç —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!")
            logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∑–∞–ø—Ä–æ—Å –æ—Ç {user_id}")

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ {user_id}: {e}")
        try:
            if processing_msg:
                await processing_msg.edit_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ: {str(e)}")
            else:
                await message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ: {str(e)}")
        except Exception as reply_error:
            logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ: {reply_error}")
    finally:
        user_processing[user_id] = False
        cleanup_old_processed_messages()
        
        # –û—á–∏—Å—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
        try:
            await cleanup_user_message(message)
            if processing_msg:
                await asyncio.sleep(5)
                await processing_msg.delete()
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏–π: {e}")

# ------------------------- –ó–ê–ü–£–°–ö –ë–û–¢–ê -------------------------
if __name__ == "__main__":
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ Instagram Downloader Bot...")
    
    # –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    os.makedirs("downloads", exist_ok=True)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
    try:
        import filetype
        logger.info("‚úÖ –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ filetype –¥–æ—Å—Ç—É–ø–Ω–∞")
    except ImportError:
        logger.warning("‚ö†Ô∏è –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ filetype –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π –æ—Ç–∫–ª—é—á–µ–Ω–∞")
    
    app.run()
    logger.info("üëã –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
